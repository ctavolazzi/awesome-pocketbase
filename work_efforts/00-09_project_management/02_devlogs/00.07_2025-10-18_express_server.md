# DevLog: Express API Server Architecture

**Date:** 2025-10-18
**Session:** 20:53 PDT
**Work Effort:** [[../01_work_efforts/00.06_express_api_server]]

## Overview
Built a production-ready Express API server to serve as an intermediary layer between the frontend and PocketBase. This architectural decision enables centralized validation, business logic, and provides a foundation for future authentication and authorization.

## Architectural Decisions

### 1. Why Express Over Alternatives?

**Decision:** Use Express.js as the web framework

**Rationale:**
- Minimal and unopinionated
- Excellent middleware ecosystem
- Well-documented and battle-tested
- Easy dependency injection for testing
- Node.js native test runner compatibility

**Alternatives Considered:**
- Fastify - More performant but less mature ecosystem
- Koa - More modern but smaller community
- Direct PocketBase hooks - Less flexible for complex logic

### 2. Validation Strategy

**Decision:** Reuse frontend schemas on backend

**Rationale:**
- Single source of truth for validation rules
- Prevents schema drift between frontend/backend
- Validation happens before PocketBase call
- Field-level error messages for better UX

**Implementation:**
- Import schemas from `public/schemas/`
- Validate in post service before PB call
- Return 422 with detailed error messages

**Trade-offs:**
- ‚úÖ Consistency guaranteed
- ‚úÖ Less code duplication
- ‚ö†Ô∏è Frontend schemas must be Node.js compatible

### 3. Authentication Strategy

**Decision:** Admin auto-authentication with retry on 401

**Rationale:**
- Server acts as trusted admin client
- No per-request auth token needed
- Auto-retry handles token expiration
- Prevents auth race conditions

**Implementation:**
```javascript
async function executeWithAuth(action) {
  await ensureAuth();
  try {
    return await action(pb);
  } catch (err) {
    if (err?.status === 401) {
      pb.authStore.clear();
      await authenticate('retry after 401');
      return action(pb);
    }
    throw err;
  }
}
```

**Security Note:**
- Admin credentials in environment variables
- Not suitable for user-facing endpoints without additional auth layer

### 4. Error Handling Architecture

**Decision:** Custom error types with centralized middleware

**Rationale:**
- Consistent error responses across all endpoints
- Structured error format for frontend parsing
- Automatic 5xx error logging
- Field-level validation details

**Error Types:**
- `HttpError` - Generic HTTP errors with status codes
- `ValidationError` - 422 errors with field details

**Response Format:**
```json
{
  "error": "Human-readable message",
  "details": {
    "issues": [
      {"path": ["title"], "message": "Required field"}
    ]
  }
}
```

### 5. Logging Strategy

**Decision:** Structured JSON logging with context

**Rationale:**
- Machine-readable for log aggregation tools
- Context tracking for debugging
- Timestamp on every message
- Level-based filtering (debug/info/warn/error)

**Log Format:**
```
[ISO_TIMESTAMP] [LEVEL] message {"contextKey": "value"}
```

**Levels:**
- `debug` - Development details (service calls, validation)
- `info` - Normal operations (server start, mutations)
- `warn` - Warning conditions (401 retry)
- `error` - Error conditions (unhandled errors)

### 6. Testing Approach

**Decision:** Unit tests for services, integration tests for routes

**Rationale:**
- Fast test execution (<100ms total)
- No database dependencies
- Mock services for route testing
- Pure function testing for business logic

**Coverage:**
- Service layer: slug generation, validation, merging
- Route layer: request handling, dependency injection
- Error cases: 404, validation failures

**Test Runner:** Node.js native `node:test` module
- No external dependencies
- Modern async/await support
- Built-in mocking

## Technical Implementation

### Dependency Injection Pattern

**Routes accept service dependencies:**
```javascript
export function createPostsRouter(deps = postService) {
  const router = Router();
  router.post('/', async (req, res) => {
    const created = await deps.createPost(req.body);
    res.status(201).json(created);
  });
  return router;
}
```

**Benefits:**
- Easy to mock in tests
- Flexible for different implementations
- Clear dependencies

### Async Error Handling

**asyncHandler wrapper:**
```javascript
function asyncHandler(fn) {
  return function handler(req, res, next) {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}
```

**Purpose:**
- Catches async errors in route handlers
- Forwards to error middleware
- Prevents unhandled promise rejections

### Slug Generation

**Business Logic:**
```javascript
function slugify(input) {
  return input
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .slice(0, 140);
}
```

**Auto-generation:**
- If slug missing but title present ‚Üí generate
- If slug empty but title present ‚Üí generate
- Otherwise use provided slug

### Update Merging

**Partial update strategy:**
```javascript
function buildUpdatePayload(existing, patch) {
  // 1. Merge existing + patch
  const merged = { ...existing, ...patch };

  // 2. Apply defaults (e.g., slug from title)
  const normalized = ensureDefaults(merged);

  // 3. Validate complete merged result
  validate(normalized, postCreateSchema);

  // 4. Extract only changed fields
  const payload = {};
  for (const field of UPDATE_FIELDS) {
    if (patch[field] !== undefined) {
      payload[field] = patch[field];
    }
  }

  return { payload, merged };
}
```

**Rationale:**
- Validates complete record (all required fields present)
- Only sends changed fields to PocketBase
- Prevents breaking existing valid records

## Performance Considerations

### Single PocketBase Instance
- One shared PocketBase client across all requests
- Authenticated once on startup
- Token reused for all operations

### Minimal Overhead
- No ORM layer
- Direct PocketBase SDK calls
- Validation only, no transformation
- Streaming JSON responses

### Bottlenecks to Watch
- PocketBase response times (network + DB)
- Validation complexity (schema size)
- JSON parsing (1MB limit set)

## Security Audit

### ‚úÖ Implemented
- Environment variables for credentials
- Input validation on all endpoints
- Request size limits (1MB)
- Structured error messages (no stack traces)
- Field-level validation

### ‚ö†Ô∏è Missing (Required for Production)
- **CORS:** No cross-origin configuration
- **Rate Limiting:** No request throttling
- **Authentication:** Server uses admin auth, but no user auth
- **Authorization:** No role-based access control
- **HTTPS:** No TLS configuration
- **Security Headers:** No helmet.js or equivalent
- **Input Sanitization:** Basic validation only, no XSS protection
- **SQL Injection:** PocketBase SDK handles this, but not verified

### üîí Recommendations

**Immediate (Before Frontend Integration):**
1. Add CORS middleware:
```javascript
import cors from 'cors';
app.use(cors({
  origin: ['http://localhost:4173', 'http://127.0.0.1:4173'],
  credentials: true
}));
```

2. Add rate limiting:
```javascript
import rateLimit from 'express-rate-limit';
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use('/api/', limiter);
```

**Before Production:**
1. Add user authentication middleware
2. Implement role-based authorization
3. Add helmet.js for security headers
4. Set up HTTPS/TLS
5. Add request logging for security monitoring
6. Implement request sanitization
7. Add CSRF protection

## Integration Points

### Current Architecture
```
Frontend (port 4173)
    ‚Üì
PocketBase SDK (direct connection)
    ‚Üì
PocketBase (port 8090)
```

### Target Architecture
```
Frontend (port 4173)
    ‚Üì
Express API (port 3030)
    ‚Üì
PocketBase SDK
    ‚Üì
PocketBase (port 8090)

Frontend (port 4173)
    ‚Üì (realtime only)
PocketBase SDK
    ‚Üì
PocketBase (port 8090)
```

**Hybrid Approach:**
- Mutations (create/update/delete) ‚Üí Express API
- Realtime subscriptions ‚Üí Direct PocketBase
- Reads ‚Üí Could go either way (optimize later)

## Testing Results

### Test Execution
```bash
$ npm run test:server

‚ñ∂ slugify produces lowercase kebab strings without special chars
‚úî slugify produces lowercase kebab strings without special chars (0.5ms)

‚ñ∂ ensureDefaults adds fallback status and slug
‚úî ensureDefaults adds fallback status and slug (0.2ms)

‚ñ∂ validateForCreate returns payload with derived slug
‚úî validateForCreate returns payload with derived slug (0.3ms)

‚ñ∂ validateForCreate throws ValidationError on missing required data
‚úî validateForCreate throws ValidationError on missing required data (0.4ms)

‚ñ∂ buildUpdatePayload merges existing data and validates final result
‚úî buildUpdatePayload merges existing data and validates final result (0.3ms)

‚ñ∂ buildUpdatePayload throws when post is missing
‚úî buildUpdatePayload throws when post is missing (0.2ms)

‚ñ∂ buildUpdatePayload surfaces validation failures
‚úî buildUpdatePayload surfaces validation failures (0.3ms)

‚ñ∂ GET /api/posts proxies to listPosts service
‚úî GET /api/posts proxies to listPosts service (1.2ms)

‚ñ∂ GET /api/posts/:id returns single record
‚úî GET /api/posts/:id returns single record (0.8ms)

‚ñ∂ POST /api/posts sends body to createPost service
‚úî POST /api/posts sends body to createPost service (0.7ms)

‚ñ∂ PATCH /api/posts/:id forwards data to updatePost service
‚úî PATCH /api/posts/:id forwards data to updatePost service (0.9ms)

‚Ñπ tests 11
‚Ñπ suites 0
‚Ñπ pass 11
‚Ñπ fail 0
‚Ñπ cancelled 0
‚Ñπ skipped 0
‚Ñπ todo 0
‚Ñπ duration_ms 45.2
```

**Results:** ‚úÖ 11/11 tests passing, <50ms execution time

## Next Session Priorities

### P0 (Blocking Frontend Integration)
1. Add CORS configuration
2. Test Express server with live PocketBase
3. Create API client service in frontend
4. Update composer to use Express API

### P1 (Production Requirements)
1. Create `.env.example` template
2. Add rate limiting
3. Implement user authentication
4. Add security headers

### P2 (Nice to Have)
1. Add request timing middleware
2. Implement response caching
3. Add API documentation (OpenAPI/Swagger)
4. Docker containerization

## Lessons Learned

### What Went Well
- Dependency injection made testing trivial
- Shared schemas prevented duplication
- Structured logging made debugging easy
- Auto-retry on 401 handled edge case cleanly

### What Could Be Better
- Should have added CORS from the start
- Need better documentation for environment setup
- Test coverage could include E2E with real PocketBase
- Should have created `.env.example` alongside implementation

### Future Improvements
- Consider moving to TypeScript for type safety
- Add OpenAPI schema generation
- Implement request/response interceptors
- Add performance monitoring middleware

## Related Work
- [[00.03_data_api_layer]] - Initial data layer concepts
- [[00.05_optimistic_composer]] - Frontend optimistic UI
- [[../01_work_efforts/00.06_express_api_server]] - Complete implementation details

## Files Created/Modified
```
server/
‚îú‚îÄ‚îÄ index.mjs (new)
‚îú‚îÄ‚îÄ routes/posts.mjs (new)
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ pocketbaseClient.mjs (new)
‚îÇ   ‚îî‚îÄ‚îÄ postService.mjs (new)
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ errors.mjs (new)
‚îÇ   ‚îî‚îÄ‚îÄ logger.mjs (new)
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ postService.test.mjs (new)
    ‚îî‚îÄ‚îÄ postsRoutes.test.mjs (new)

package.json (modified)
```

## Last Updated
2025-10-18 20:53
